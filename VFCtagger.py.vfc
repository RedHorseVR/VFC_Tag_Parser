;  IRL FlowCode Version: Version 10.0
;  c1995-2015: Visual Flow Coder by 2LResearch
;
;  File Name : VFCtagger.py.vfc
;  File Date : 05:15:45 PM - 22:Mar:2025

event(import argparse);//
event(import os);//
event(import re);//
event(import sys);//
event(import importlib);//
end();//
set(lang = None);//
set(lang_commentmarker = '');//
end();//

input(def  process_tabbed_file( tabfile ):);//
set(TABS =0);//
set(last_TAB = 0);//
set(marked_file = []);//
set(marked_line =  f'{ lang_commentmarker } set ');//////////
output();//print(  marked_line  )
process(marked_file.append( marked_line ););//////////
process(marked_file.append( marked_line ););//////
loop(for i in range ( 0 , len(tabfile) - 2 )  :);//for line  in tabfile :
set(line = tabfile[ i ]);//
output();//print( line  ) ; input('>')
branch(if  not  line.strip().startswith( lang_commentmarker )  :);//
path();//
process(line = lang.lang_filter( line ));//
set(last_TAB = TABS);//
set(TABS = len( line ) - len( line.lstrip('\t') ));//
process(nextline = lang.lang_check_path( tabfile[i+1] ));//
set(next_TABS = len( nextline  ) - len( nextline.lstrip('\t') ));//
set(tabrate = last_TAB-TABS);//
set(next_tabrate = TABS - next_TABS);//
branch(if   next_tabrate == 1  :);//
path();//
set(marked_line =  f'\t' * (TABS) + f'{ lang_commentmarker } { lang.pop() } ');//
process(marked_file.append( marked_line ););//////
output();//print(  f'{TABS-1} {line}'  )
path(else: );//
set(marked_line =  f'{line}');////pass//
process(marked_file.append( marked_line ););//////
bend( );//
output();//print( '---->' , next_tabrate )
loop(for rate in range( 2, next_tabrate ):);//<---- in case we hit some tabs that may be missing and need to close sevearl items on a single line tab
set(marked_line =  f'\t' * (TABS) + f'{ lang_commentmarker } { lang.pop() } ');//
process(marked_file.append( marked_line ););//////
lend( );//
path(else: );//
generic(newline = line.replace( "\t" , "" ));// ////
set(marked_line =  f'{ newline  } {lang_commentmarker} set');// 
process(marked_file.append( marked_line ););//////
output();//print( marked_line  ) ; input('>')
bend( );//
lend( );//
set();//line = tabfile[ len(tabfile) - 1 ]
end(return marked_file);//

input(def gettabbed_file(filename):);//
set(filename = filename.strip());//
output(print( '------------------------------------------------') );//
output(print( filename ));//
set(tabbed_file = []);//
branch(try:  );// // branch //
path();//
generic(LINE = ' ');// ////
set(TABS =0);//
branch(with open(filename, 'r') as file:  );// // branch //
path();//
set(IN_COMMENT_BLOCK = False;);//
set(i = 0 );//
set(last_TAB = 0);//
loop(for line in file:  );// // loop //
generic(linet = line.replace('    ', '\t').strip( "\n" ));//
generic(LINE2 = line.replace('    ', '\t').strip( "\n" ));//
branch(if  not linet.strip() == ''    :);//
path();//
branch(if  not IN_COMMENT_BLOCK and not line.startswith('\n')  and not line.lstrip().startswith('#') :);//
path( );//
set(i +=1 );//
generic(IN_COMMENT_BLOCK = line.strip().startswith( '"""'  ));//
branch(if IN_COMMENT_BLOCK   :);//
path( );//
output(pass);//print( f'{ "##" }  { linet  }'  )
set(tabbed_file.append( lang_commentmarker  + line ));//
path(else: );//
set(last_TAB = TABS);//
set(TABS = len( linet ) - len( linet.lstrip('\t') ));//
generic(LINE2 = line.replace('    ', '\t').strip( "\n" ));//LINE2 = line.replace('    ', '\t.').strip( "\n" )
process();//LINE2 = lang_filter( LINE2 )
generic(LINE = line.replace('    ', '\t.').strip( "\n" ));//
process();//LINE = lang_filter( LINE )
generic(diff = TABS - last_TAB);// 
branch(if  diff < 0   :);// 
path();//
loop(for tabs in range(  last_TAB , TABS , -1 ) :);//
generic(FillLINE = '\t.' * tabs);// FillLINE = '\t.' * (last_TAB-1)
generic(FillLINE2 = '\t' * tabs);//FillLINE2 = '\t.' * tabs
output( );//print( f'{ tabs }---->  { FillLINE }' )
set(tabbed_file.append( FillLINE2  ));//
lend( );//
bend( );//
output();//print( f'{ TABS } : { diff }   { LINE  }' )
set(tabbed_file.append( LINE2  ));//
bend( );//
path(else: );//
branch(if  IN_COMMENT_BLOCK   :);//
path();//
set(tabbed_file.append( lang_commentmarker  + line ));//
bend( );//
branch(if line.strip().endswith( '"""'  )  :);//
path( );//
set(IN_COMMENT_BLOCK = False;);//
bend( );//
output( );//print( f'{ "##"  }  { linet }' )
bend( );//
path(else: );//
output(print( '------------------------------------------------') );//
bend( );//
lend();// // lend //
bend();// // bend //
path(except FileNotFoundError:  );//
output(print(f"The file '{filename}' was not found."));//
path(except Exception as e:  );//// // branch ////
output(print(f"An error occurred: {e}"));//// // General error handling ////
bend();// // bend //
end(return tabbed_file);//

input(def import_language( LANG ):);//
branch( try:);//    
path();//
set(lang  = importlib.import_module(f"languages.{  LANG  }_lang"));//
path( except ImportError as e:);//    
output(sys.exit(f"Error loading lang module: {e}"));/////////
bend(  );//    
end(return lang);//

input(def extract_rightmost_pattern(string, words, marker):);//// //////
generic(patterns = [f"{marker} {word}" for word in words]);// ////
generic(matches = [pattern for pattern in patterns if pattern in string]);// ////
end(return max(matches, key=string.rfind) if matches else ' generic');//
end();//

input(def split_line_on_comment(line, comment_marker ) :);//// //'): ////
generic(in_literal = None );// ////
generic(codeline = [] );// ////
generic(comment = [] );// ////
loop(for i, char in enumerate(line): );//// //////
generic();// // Check if we are entering or exiting a literal //
branch(if char in ["'", '"', '`']:);//
path();//
branch(if in_literal is None:  );//// // Entering a literal ////
path();//
generic(in_literal = char );// ////
path(elif in_literal == char:  );//// // Exiting the literal ////
generic(in_literal = None );// ////
bend();//// // Check for the comment marker if we're not inside a literal ////
path(elif char == comment_marker and in_literal is None: );////// ////////
generic();// // Switch to capturing the comment //
generic(comment.append(line[i:])  );// // Add the rest of the line as the comment //
end(return ''.join(codeline), ''.join(comment) );//// //////
bend();//// // Add to the codeline if we're not inside a comment ////
generic(codeline.append(char) );// ////
generic();// // If no comment marker is found, return the entire line as code and an empty comment //
lend();//////
generic(return ''.join(codeline), '' );// ////
end();//// // Example usage ////

input(def  mark2flow( marked_line ):);//
generic(codeline , comment  =  split_line_on_comment( marked_line ,  lang_commentmarker ));//
generic(VFC_DIVIDER = '//');// 
set(keytoks = [ 'input' , 'event' , 'output' , 'set', 'process' , 'branch', 'path', 'bend' , 'loop' ,'lend' , 'end'  ]);//
generic(result = extract_rightmost_pattern( comment , keytoks , lang_commentmarker ));// ////
generic(result =result[1:].strip());// 
set(flowline = f'{ result }({ codeline.strip() });{VFC_DIVIDER}  {comment.replace( result, "").replace( lang_commentmarker, "")  }');//
end(return flowline);//
branch(if __name__ == "__main__":);//////
path();//
branch(if len( sys.argv ) > 2 :);//
path( );//
set(CODEFILE = sys.argv[1]);///LANG = args.language.lower( )//
set(LANG = sys.argv[2]);///LANGUAGE = args.language.lower( )//
path(else: );//
set(CODEFILE = "TEST2\python1.py");///LANG = args.language.lower( )//
set(LANG = "python");///LANGUAGE = args.language.lower( )//
bend( );//
event(lang = import_language( LANG  ));//
set(lang_commentmarker = lang.lang_commentmarker);//
path();//////////
output( lang.pretty_print( CODEFILE ));//
set(tabfile = gettabbed_file( CODEFILE ));//////
process(marked_file = process_tabbed_file( tabfile ) ;);//
set(output_file = CODEFILE + '.vfc');//
branch( with open(output_file, "w", encoding="utf-8") as out:);//    
path();//
loop(for line in marked_file :);//
set(vfcline =  mark2flow( line ));//
branch(if  vfcline.startswith( 'input' )   :);//<--------   insert a endbefoer an input
path();//
output(print( 'end();'  ));// 
output(out.write( 'end();'+ '\n' ));//
bend( );//
output(print( vfcline  ));//print( line )
output(out.write( vfcline + '\n' ));//
branch(if  vfcline.startswith( 'branch' )   :);//<-------- needs to insert a path since we processed paths and linear tokens
path();//
output(print( 'path();'  ));//print( line )
output(out.write( 'path();'+ '\n' ));//
bend( );//
lend( );//
end(exit);//////////
bend();//
bend();//
end();//



;INSECTA EMBEDDED SESSION INFORMATION
; 255 16777215 65280 16777088 16711680 13158600 16744703 0 255 255 65535 6946660 0
;    VFCtagger.py   #   .
; notepad++.exe
;INSECTA EMBEDDED ALTSESSION INFORMATION
; 703 20 2710 2081 9 96   1291   219    python.key  0